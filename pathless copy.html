<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>{{.Title}}</title>
		<link rel="icon" type="image/" href="{{.Favicon}}" />
		<style>
			:root {
				--border: medium solid blue;
			}
			* {
				box-sizing: border-box;
				margin: 0;
				padding: 0;
				user-select: none;
				scrollbar-width: none;
				-ms-overflow-style: none;
			}
			*::-webkit-scrollbar {
				display: none;
			}
			html,
			body {
				height: 100vh;
				overflow: hidden;
				font-family: sans-serif, monospace;
				background: black;
				color: white;
				scroll-behavior: smooth;
			}
			body {
				border: var(--border);
				border-radius: 0.3125em;
			}
			a {
				color: inherit;
				text-decoration: underline;
				text-align: center;
			}
			#app {
				height: 100vh;
				display: grid;
			}
			.panel {
				display: flex;
				align-items: center;
				justify-content: center;
				padding: 1em;
				overflow: hidden;
			}
			.panel > * {
				width: 100%;
				height: 100%;
			}
			/* Layout 0-0: Single fullscreen panel */
			.layout-0-0 {
				grid-template: 1fr / 1fr;
			}
			/* Layout 1-0: Two panels side-by-side */
			.layout-1-0 {
				grid-template: 1fr / 1fr 1fr;
			}
			.layout-1-0 #zero {
				border-right: var(--border);
			}
			/* Layout 1-1: Two panels stacked vertically */
			.layout-1-1 {
				grid-template: 1fr 1fr / 1fr;
			}
			.layout-1-1 #zero {
				border-bottom: var(--border);
			}
			/* Layout 2-x: Three panels in 2x2 grid */
			.layout-2-0,
			.layout-2-1,
			.layout-2-2,
			.layout-2-3 {
				grid-template: 1fr 1fr / 1fr 1fr;
			}
			/* Layout 2-0: Left full-height, right split */
			.layout-2-0 #zero {
				grid-row: 1 / 3;
				border-right: var(--border);
			}
			.layout-2-0 #one {
				border-bottom: var(--border);
			}
			/* Layout 2-1: Top full-width, bottom split */
			.layout-2-1 #zero {
				grid-column: 1 / 3;
				border-bottom: var(--border);
			}
			.layout-2-1 #one {
				border-right: var(--border);
			}
			/* Layout 2-2: Right full-height, left split */
			.layout-2-2 #zero {
				grid-row: 1 / 3;
				grid-column: 2;
				border-left: var(--border);
			}
			.layout-2-2 #one {
				border-bottom: var(--border);
			}
			/* Layout 2-3: Bottom full-width, top split */
			.layout-2-3 #zero {
				grid-row: 2;
				grid-column: 1 / 3;
				border-top: var(--border);
			}
			.layout-2-3 #one {
				border-right: var(--border);
			}
			#keyboard {
				position: fixed;
				left: 2em;
				bottom: 7em;
				z-index: 11;
				display: none;
				background: #111;
				border-radius: 0.75em;
				box-shadow: 0 0.25em 1.5em #000a;
				padding: 1em;
				width: 20em;
				max-width: 90vw;
			}
			#keyboard.visible {
				display: flex;
			}
			.grid {
				display: grid;
				grid-template-columns: repeat(3, 1fr);
				grid-template-rows: repeat(4, 1fr);
				gap: 0.5em;
				width: 100%;
			}
			.key {
				border: medium solid #444;
				border-radius: 0.375em;
				height: 3em;
				display: flex;
				align-items: center;
				justify-content: center;
				font-weight: 600;
				font-size: 1.3em;
				background: #222;
				color: white;
			}
			.key.pressed {
				border-color: #fff;
				background: #333;
			}
			.key:empty {
				opacity: 0;
				pointer-events: none;
			}
		</style>
		<script>
			class One {
				constructor() {
					// Prevent multiple initializations
					if (window.one) return window.one;

					window.apiUrl = '{{.APIURL}}';
					this.fx = new Fx();
					this.fx.render();

					// Map<key, { action?, down?, up?, label?, style?, pressed? }>
					this.event = new Map();
					this.pressedKeys = new Set();

					// Register global actions
					this.event.set('q', {
						action: () => this.fx.navigate(-1),
						style: 'border-color:red',
					});
					this.event.set('e', {
						action: () => this.fx.navigate(1),
						style: 'border-color:blue',
					});
					this.event.set('1', {
						action: () => this.fx.toggleFullscreen(),
					});
					this.event.set('2', { action: () => this.fx.setLayout(1) });
					this.event.set('3', { action: () => this.fx.setLayout(2) });
					this.event.set('Tab', {
						action: (e) => (
							e.preventDefault(), this.fx.cycleFocus()
						),
					});
					this.event.set('z', { up: () => this.toggleKeyboard() });

					this.initKeyboard();

					// Only add listeners once
					this.boundHandleKeyDown = (e) => this.handleKey(e, 'down');
					this.boundHandleKeyUp = (e) => this.handleKey(e, 'up');

					document.addEventListener(
						'keydown',
						this.boundHandleKeyDown
					);
					document.addEventListener('keyup', this.boundHandleKeyUp);
				}

				initKeyboard() {
					const gridLayout = [
						'Tab',
						'',
						'',
						'1',
						'2',
						'3',
						'q',
						'w',
						'e',
						'a',
						's',
						'd',
					];

					this.keyboard = document.getElementById('keyboard');
					const grid = this.keyboard.querySelector('.grid');
					this.keyElements = new Map();

					for (const key of gridLayout) {
						const el = document.createElement('div');
						el.className = 'key';

						if (key) {
							const eventDef = this.event.get(key);
							el.textContent =
								eventDef?.label ?? key.toUpperCase();
							if (eventDef?.style)
								el.style.cssText += `;${eventDef.style}`;
							this.keyElements.set(key, el);
						}

						grid.appendChild(el);
					}

					this.keyboardVisible = false;
				}

				toggleKeyboard() {
					this.keyboardVisible = !this.keyboardVisible;
					this.keyboard.classList.toggle(
						'visible',
						this.keyboardVisible
					);
				}

				handleKey(e, type) {
					const isDown = type === 'down';

					// Update pressed state
					this.pressedKeys[isDown ? 'add' : 'delete'](e.key);

					// Update keyboard overlay
					this.keyElements
						.get(e.key)
						?.classList.toggle('pressed', isDown);

					// Get key definition and execute handler
					const keyDef = this.event.get(e.key);
					if (keyDef) {
						keyDef.pressed = isDown;
						const handler = keyDef.action ?? keyDef[type];
						if (handler) {
							handler(e, keyDef);
							return;
						}
					}

					// Fall back to frame-specific handler
					const k = `${this.fx.panel.id}-${this.fx.panel.frame}`;
					const handler = this.fx.handlers.get(k);
					if (!handler) return;

					if (typeof handler === 'function' && isDown) {
						handler(e.key, keyDef);
					} else {
						handler[type]?.(e.key, keyDef);
					}
				}
			}

			/* Layout & rendering manager */
			class Fx {
				constructor() {
					this.zero = new Zero();
					this.app = document.getElementById('app');
					this.panels = ['zero', 'one', 'two'].map((id) => {
						const el = document.getElementById(id);
						el.frame = 0;
						el.state = new Map();
						return el;
					});
					this.layout = [0, 0];
					this.focus = 0;
					this.prev = null;
					this.handlers = new Map();
					this.variants = [0, 1, 3];
				}

				get panel() {
					return this.panels[this.focus];
				}

				get count() {
					return this.layout[0] + 1;
				}

				get state() {
					const { frame } = this.panel;
					return this.panel.state.get(frame) ?? {};
				}

				update(k, v) {
					const { panel } = this;
					const { frame } = panel;
					if (!panel.state.has(frame)) panel.state.set(frame, {});
					panel.state.get(frame)[k] = v;
				}

				async toggleFullscreen() {
					if (this.layout[0] === 0 && this.prev) {
						this.layout = [...this.prev];
						this.prev = null;
					} else if (this.layout[0] !== 0) {
						this.prev = [...this.layout];
						this.layout = [0, 0];
					}
					await this.render();
				}

				async setLayout(i) {
					this.prev = null;
					this.focus = Math.min(this.focus, i);
					const numVariants = this.variants[i] + 1;

					if (this.layout[0] === i) {
						this.layout = [
							this.layout[0],
							(this.layout[1] + 1) % numVariants,
						];
					} else {
						this.layout = [i, 0];
					}
					await this.render();
				}

				cycleFocus() {
					this.focus = (this.focus + 1) % this.count;
					this.display();
				}

				async navigate(d) {
					const t = this.zero.totalFrames ?? 1;
					const { panel } = this;
					panel.frame = (((panel.frame + d) % t) + t) % t;
					await this.render();
				}

				async render() {
					const updates = [];

					for (let i = 0; i < this.count; i++) {
						const panel = this.panels[i];
						const html = await this.zero.fetchFrame(panel.frame);

						if (panel._lastHtml !== html) {
							const tmp = document.createElement('div');
							tmp.innerHTML = html;

							// Only re-execute scripts/styles from fetched frames, not main document
							for (const tag of ['script', 'style']) {
								for (const old of tmp.querySelectorAll(tag)) {
									// Skip if script has data-main attribute (from main document)
									if (old.hasAttribute('data-main')) continue;

									const n = document.createElement(tag);
									for (const {
										name,
										value,
									} of old.attributes) {
										n.setAttribute(name, value);
									}
									n.textContent = old.textContent;
									old.replaceWith(n);
								}
							}

							const frag = document.createDocumentFragment();
							frag.append(...tmp.childNodes);
							updates.push(() => panel.replaceChildren(frag));
							panel._lastHtml = html;
						}
					}

					updates.forEach((fn) => fn());
					this.display();
				}

				display() {
					requestAnimationFrame(() => {
						this.app.className = `layout-${this.layout[0]}-${this.layout[1]}`;
						this.panels.forEach((p, i) => {
							p.style.display =
								this.layout[0] === 0
									? i === this.focus
										? 'flex'
										: 'none'
									: i < this.count
									? 'flex'
									: 'none';
						});
					});
				}
			}

			/* Data fetching & caching */
			class Zero {
				constructor() {
					this.cache = new Map();
					this.pending = new Map();
					this.totalFrames = null;
					this.url = `${window.apiUrl}/frame`;
				}

				async fetch(url, opts = {}) {
					const { key: k } = opts;

					if (k !== undefined) {
						if (this.cache.has(k)) return this.cache.get(k);
						if (this.pending.has(k)) return this.pending.get(k);
					}

					const p = fetch(url, opts)
						.then(async (r) => {
							if (!r.ok) throw new Error(`HTTP ${r.status}`);

							const ct = r.headers.get('content-type') ?? '';
							const data = ct.startsWith('image/')
								? URL.createObjectURL(await r.blob())
								: ct.includes('json')
								? await r.json()
								: await r.text();

							const res = { data, headers: r.headers };
							if (k !== undefined) this.cache.set(k, res);
							return res;
						})
						.finally(() => {
							if (k !== undefined) this.pending.delete(k);
						});

					if (k !== undefined) this.pending.set(k, p);
					return p;
				}

				async fetchFrame(i) {
					if (this.totalFrames === null) {
						const res = await this.fetch(this.url, { key: 0 });
						this.totalFrames = parseInt(
							res.headers.get('X-Frames') ?? '1',
							10
						);
						return res.data;
					}

					try {
						const res = await this.fetch(this.url, {
							headers: { 'X-Frame': String(i) },
							key: i,
						});
						return res.data;
					} catch (e) {
						return `<div>Error: ${e.message}</div>`;
					}
				}
			}

			document.addEventListener('DOMContentLoaded', () => {
				if (!window.one) {
					window.one = new One();
					window.pathless = {
						context: () => ({
							panel: window.one.fx.panel,
							frame: window.one.fx.panel.firstElementChild,
							state: window.one.fx.state,
						}),
						update: (k, v) => window.one.fx.update(k, v),
						fetch: (url, opts) =>
							window.one.fx.zero.fetch(url, opts),
						onKey: (down, up) => {
							const k = `${window.one.fx.panel.id}-${window.one.fx.panel.frame}`;
							const handler = up ? { down, up } : down;
							window.one.fx.handlers.set(k, handler);
						},
					};
				}
			});
		</script>
	</head>
	<body>
		<div id="app">
			<div id="zero" class="panel"></div>
			<div id="one" class="panel"></div>
			<div id="two" class="panel"></div>
			<div id="keyboard">
				<div class="grid"></div>
			</div>
		</div>
	</body>
</html>
