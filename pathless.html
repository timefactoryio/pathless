<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>hello.universe</title>
		<style>
			:root {
				--b: medium solid blue;
			}
			* {
				box-sizing: border-box;
				margin: 0;
				padding: 0;
				user-select: none;
				scrollbar-width: none;
			}
			*::-webkit-scrollbar {
				display: none;
			}
			html,
			body {
				height: 100vh;
				overflow: hidden;
				font-family: sans-serif;
				background: #000;
				color: #fff;
			}
			body {
				border: var(--b);
				border-radius: 5px;
			}
			a {
				color: inherit;
				text-decoration: none;
			}
			#universe {
				height: 100vh;
				display: grid;
			}
			.space {
				display: flex;
				align-items: center;
				justify-content: center;
				padding: 1em;
				overflow: hidden;
			}
			.space > * {
				width: 100%;
				height: 100%;
			}
			.space.hide {
				display: none;
			}
			.space.focused {
				animation: flash 50ms;
			}
			@keyframes flash {
				to {
					border: medium solid white;
				}
			}
			.l00 {
				grid-template: 1fr / 1fr;
			}
			.l10 {
				grid-template: 1fr / 1fr 1fr;
			}
			.l10 .zero {
				border-right: var(--b);
			}
			.l11 {
				grid-template: 1fr 1fr / 1fr;
			}
			.l11 .zero {
				border-bottom: var(--b);
			}
			.l20,
			.l21,
			.l22,
			.l23 {
				grid-template: 1fr 1fr / 1fr 1fr;
			}
			.l20 .zero {
				grid-row: 1/3;
				border-right: var(--b);
			}
			.l20 .one {
				border-bottom: var(--b);
			}
			.l21 .zero {
				grid-column: 1/3;
				border-bottom: var(--b);
			}
			.l21 .one {
				border-right: var(--b);
			}
			.l22 .zero {
				grid-row: 1/3;
				grid-column: 2;
				border-left: var(--b);
			}
			.l22 .one {
				border-bottom: var(--b);
			}
			.l23 .zero {
				grid-row: 2;
				grid-column: 1/3;
				border-top: var(--b);
			}
			.l23 .one {
				border-right: var(--b);
			}
		</style>
		<script>
			class Universe {
				constructor() {
					window.apiUrl = '{{.APIURL}}';
					this.universe = document.getElementById('universe');
					this.space = Array.from(
						document.querySelectorAll('.space')
					).map((el) => ({
						el,
						frame: [0, null],
						state: new Map(),
					}));
					this.frames = [];
					this.layout = [0, 0];
					this.prevLayout = [0, 0];
					this.focused = 0;
					this.cache = new Map();
					this.keybinds = {};
					this.overlay = {
						el: document.getElementById('overlay'),
						visible: false,
						html: null,
					};
					window.addEventListener('keydown', (e) =>
						this.handleKey(e, true)
					);
					window.addEventListener('keyup', (e) =>
						this.handleKey(e, false)
					);
					this.init();
				}

				async init() {
					const res = await fetch(`${window.apiUrl}/hello`);
					const data = await res.json();
					this.frames = data.frames;
					this.overlay.html = data.keyboard;
					this.sync();
				}

				handleKey(e, pressed) {
					const key = e.key.toLowerCase();
					const bind = this.keybinds[key];
					if (!bind) return;
					e.preventDefault();
					bind.pressed = pressed;
					if (pressed) bind.fx?.(e);
					window.dispatchEvent(
						new CustomEvent('input', {
							detail: { key, pressed },
						})
					);
				}

				onKey(key, fx, global = false) {
					this.keybinds[key.toLowerCase()] = {
						fx,
						global,
						pressed: false,
					};
					return this;
				}

				setState(key, value) {
					const s = this.space[this.focused];
					if (!s.state.has(s.frame[0]))
						s.state.set(s.frame[0], new Map());
					s.state.get(s.frame[0]).set(key, value);
				}

				getState() {
					const s = this.space[this.focused];
					return s.state.has(s.frame[0])
						? Object.fromEntries(s.state.get(s.frame[0]))
						: {};
				}

				fullscreen() {
					if (this.layout[0]) {
						this.prevLayout = [...this.layout];
						this.layout = [0, 0];
					} else {
						this.layout = [...this.prevLayout];
					}
					this.sync();
				}

				toggleOverlay() {
					this.overlay.visible = !this.overlay.visible;
					this.overlay.el.classList.toggle(
						'hidden',
						!this.overlay.visible
					);
					if (
						this.overlay.visible &&
						this.overlay.html &&
						!this.overlay.initialized
					) {
						this.overlay.el.innerHTML = this.overlay.html;
						this.exec(this.overlay.el);
						this.overlay.initialized = true;
					}
				}

				setLayout(n) {
					this.focused = Math.min(this.focused, n);
					this.layout =
						this.layout[0] === n
							? [n, (this.layout[1] + 1) % [0, 2, 4][n]]
							: [n, 0];
					this.sync();
				}

				refresh() {
					Object.keys(this.keybinds).forEach((k) => {
						if (!this.keybinds[k].global) delete this.keybinds[k];
					});
				}

				cycleFocus() {
					this.refresh();
					this.space.forEach((s) => s.el.classList.remove('focused'));
					this.focused = (this.focused + 1) % (this.layout[0] + 1);
					this.space[this.focused].el.classList.add('focused');
					this.sync(true);
				}

				nav(dir) {
					const s = this.space[this.focused];
					s.frame[0] =
						(s.frame[0] + dir + this.frames.length) %
						this.frames.length;
					this.refresh();
					this.sync();
				}

				exec(target) {
					const el = target || this.space[this.focused].el;
					['script', 'style'].forEach((tag) => {
						el.querySelectorAll(tag).forEach((old) => {
							const n = document.createElement(tag);
							for (const a of old.attributes)
								n.setAttribute(a.name, a.value);
							n.textContent = old.textContent;
							old.replaceWith(n);
						});
					});
				}

				sync(reexec = false) {
					this.universe.className = `l${this.layout[0]}${this.layout[1]}`;
					this.space.forEach((s, i) => {
						const visible =
							this.layout[0] === 0
								? i === this.focused
								: i < this.layout[0] + 1;
						const html = this.frames[s.frame[0]];
						s.el.classList.toggle('hide', !visible);
						if (visible && html !== s.frame[1]) {
							s.el.innerHTML = html;
							this.exec(s.el);
							s.frame[1] = html;
						} else if (visible && reexec && i === this.focused) {
							this.exec(s.el);
						}
					});
					if (this.overlay.initialized && window.keyboard) {
						window.keyboard.sync(this.layout, this.prevLayout);
					}
				}

				async fetch(url) {
					if (this.cache.has(url)) return this.cache.get(url);
					const promise = fetch(url).then(async (r) => {
						if (!r.ok) throw new Error(`HTTP ${r.status}`);
						const ct = r.headers.get('content-type') || '';
						return {
							data: ct.includes('json')
								? await r.json()
								: ct.startsWith('text/')
								? await r.text()
								: URL.createObjectURL(await r.blob()),
							headers: r.headers,
						};
					});
					this.cache.set(url, promise);
					return promise;
				}
			}

			document.addEventListener('DOMContentLoaded', () => {
				const u = new Universe();
				u.onKey('tab', () => u.cycleFocus(), true);
				u.onKey('1', () => u.fullscreen(), true);
				u.onKey('2', () => u.setLayout(1), true);
				u.onKey('3', () => u.setLayout(2), true);
				u.onKey('q', () => u.nav(-1), true);
				u.onKey('e', () => u.nav(1), true);
				u.onKey('z', () => u.toggleOverlay(), true);

				window.pathless = {
					space: (index) => u.space[index ?? u.focused].el,
					frame: () => u.space[u.focused].el.firstElementChild,
					update: (key, value) => u.setState(key, value),
					state: () => u.getState(),
					fetch: (url) => u.fetch(url),
					onKey: (key, fx, global) => u.onKey(key, fx, global),
					keyboard: () => [u.keybinds, u.layout, u.overlay],
				};
			});
		</script>
	</head>
	<body>
		<div id="universe">
			<div class="space zero"></div>
			<div class="space one"></div>
			<div class="space two"></div>
			<div id="overlay"></div>
		</div>
	</body>
</html>
