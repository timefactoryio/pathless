<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Pathless</title>
		<style>
			:root {
				--b: medium solid blue;
			}
			* {
				box-sizing: border-box;
				margin: 0;
				padding: 0;
				user-select: none;
				scrollbar-width: none;
			}
			*::-webkit-scrollbar {
				display: none;
			}
			html,
			body {
				height: 100vh;
				overflow: hidden;
				font-family: sans-serif;
				background: #000;
				color: #fff;
			}
			body {
				border: var(--b);
				border-radius: 5px;
			}
			a {
				color: inherit;
				text-decoration: underline;
			}
			#app {
				height: 100vh;
				display: grid;
			}
			.p {
				display: flex;
				align-items: center;
				justify-content: center;
				padding: 1em;
				overflow: hidden;
			}
			.p > * {
				width: 100%;
				height: 100%;
			}

			.l00 {
				grid-template: 1fr / 1fr;
			}
			.l10 {
				grid-template: 1fr / 1fr 1fr;
			}
			.l10 .p0 {
				border-right: var(--b);
			}
			.l11 {
				grid-template: 1fr 1fr / 1fr;
			}
			.l11 .p0 {
				border-bottom: var(--b);
			}
			.l20,
			.l21,
			.l22,
			.l23 {
				grid-template: 1fr 1fr / 1fr 1fr;
			}
			.l20 .p0 {
				grid-row: 1/3;
				border-right: var(--b);
			}
			.l20 .p1 {
				border-bottom: var(--b);
			}
			.l21 .p0 {
				grid-column: 1/3;
				border-bottom: var(--b);
			}
			.l21 .p1 {
				border-right: var(--b);
			}
			.l22 .p0 {
				grid-row: 1/3;
				grid-column: 2;
				border-left: var(--b);
			}
			.l22 .p1 {
				border-bottom: var(--b);
			}
			.l23 .p0 {
				grid-row: 2;
				grid-column: 1/3;
				border-top: var(--b);
			}
			.l23 .p1 {
				border-right: var(--b);
			}
			.keyboard {
				position: absolute;
				left: 50%;
				bottom: 2em;
				transform: translateX(-50%);
				z-index: 1000;
				display: none;
				background: #111;
				border-radius: 0.75em;
				box-shadow: 0 0.25em 1.5em #000a;
				padding: 1em;
			}
			.keyboard.visible {
				display: block;
			}
			.grid {
				display: grid;
				grid-template-columns: repeat(3, 1fr);
				grid-template-rows: repeat(4, 1fr);
				gap: 0.5em;
				width: 100%;
			}
			.key {
				border: medium solid #444;
				border-radius: 0.375em;
				height: 4em;
				width: 5em;
				display: flex;
				align-items: center;
				justify-content: center;
				font-weight: 600;
				font-size: 1.3em;
				color: white;
			}
			.key.pressed {
				border-color: #fff;
				background: #333;
			}
			.key:empty {
				opacity: 0;
				pointer-events: none;
			}
		</style>
	</head>
	<body>
		<div id="app">
			<div class="p p0"></div>
			<div class="p p1"></div>
			<div class="p p2"></div>
			<div class="keyboard"></div>
		</div>
		<script>
			window.apiUrl = '{{.APIURL}}';
			const N = 3;
			const L = [1, 2, 3];
			const V = [0, 1, 3];

			class State {
				constructor() {
					this.cache = new Map();
					this.total = null;
					this.panels = Array.from({ length: N }, (_, i) => ({
						el: document.querySelector(`.p${i}`),
						frame: 0,
						state: new Map(),
						html: '',
					}));
					this.layout = [0, 0];
					this.prev = null;
					this.focus = 0;
					this.keymap = new Map();
					this.keyboard = document.querySelector('.keyboard');
				}

				get p() {
					return this.panels[this.focus];
				}
				get cnt() {
					return L[this.layout[0]];
				}
				get st() {
					return this.p.state.get(this.p.frame) || {};
				}

				set(k, v) {
					if (!this.p.state.has(this.p.frame))
						this.p.state.set(this.p.frame, {});
					this.p.state.get(this.p.frame)[k] = v;
				}

				async get(url, key) {
					if (key !== undefined && this.cache.has(key))
						return this.cache.get(key);
					const r = await fetch(
						url,
						key !== undefined
							? { headers: { 'X-Frame': String(key) } }
							: {}
					);
					if (!r.ok) throw new Error(`HTTP ${r.status}`);
					const ct = r.headers.get('content-type') || '';
					const data = ct.startsWith('image/')
						? URL.createObjectURL(await r.blob())
						: ct.includes('json')
						? await r.json()
						: await r.text();
					const res = { data, headers: r.headers };
					if (key !== undefined) this.cache.set(key, res);
					if (key === 0)
						this.total = parseInt(
							res.headers.get('X-Frames') || '1',
							10
						);
					return res;
				}

				async frame(i) {
					try {
						const res = await this.get(
							`${window.apiUrl}/frame`,
							i === 0 || this.total !== null ? i : 0
						);
						return res.data;
					} catch (e) {
						return `<div>Error: ${e.message}</div>`;
					}
				}

				async render() {
					for (let i = 0; i < this.cnt; i++) {
						const p = this.panels[i];
						const html = await this.frame(p.frame);
						if (p.html !== html) {
							const tmp = document.createElement('div');
							tmp.innerHTML = html;
							['script', 'style'].forEach((tag) => {
								tmp.querySelectorAll(tag).forEach((old) => {
									const n = document.createElement(tag);
									[...old.attributes].forEach((a) =>
										n.setAttribute(a.name, a.value)
									);
									n.textContent = old.textContent;
									old.replaceWith(n);
								});
							});
							p.el.replaceChildren(...tmp.childNodes);
							p.html = html;
						}
					}
					this.display();
				}

				display() {
					requestAnimationFrame(() => {
						app.className = `l${this.layout[0]}${this.layout[1]}`;
						this.panels.forEach((p, i) => {
							p.el.style.display =
								this.layout[0] === 0
									? i === this.focus
										? 'flex'
										: 'none'
									: i < this.cnt
									? 'flex'
									: 'none';
						});
					});
				}

				async nav(d) {
					const t = this.total || 1;
					this.p.frame = (((this.p.frame + d) % t) + t) % t;
					await this.render();
				}

				async full() {
					if (this.layout[0] === 0 && this.prev) {
						this.layout = [...this.prev];
						this.prev = null;
					} else if (this.layout[0] !== 0) {
						this.prev = [...this.layout];
						this.layout = [0, 0];
					}
					await this.render();
				}

				async lay(i) {
					this.prev = null;
					this.focus = Math.min(this.focus, i);
					this.layout =
						this.layout[0] === i
							? [i, (this.layout[1] + 1) % (V[i] + 1)]
							: [i, 0];
					await this.render();
				}

				cycle() {
					this.focus = (this.focus + 1) % this.cnt;
					this.display();
				}

				key(k, h, opt = {}, event) {
					if (h) {
						this.keymap.set(k, {
							fn: h,
							style: opt.style,
							data: opt.data,
						});
					} else {
						const entry = this.keymap.get(k);
						if (entry?.fn) return entry.fn(event || k, entry.data);
					}
				}

				showKeyboard() {
					const keys = [
						['Tab', '', ''],
						['1', '2', '3'],
						['q', 'w', 'e'],
						['a', 's', 'd'],
					];
					this.keyboard.innerHTML = `<div class="grid"></div>`;
					const grid = this.keyboard.querySelector('.grid');
					keys.flat().forEach((k) => {
						const entry = this.keymap.get(k);
						const keyEl = document.createElement('div');
						keyEl.className = 'key';
						keyEl.dataset.key = k;
						keyEl.textContent = k.toUpperCase();
						if (entry?.style) keyEl.style.cssText = entry.style;
						grid.appendChild(keyEl);
					});
				}

				toggleKeyboard() {
					this.keyboard.classList.toggle('visible');
					if (this.keyboard.classList.contains('visible')) {
						this.showKeyboard();
					}
				}
			}

			const s = new State();

			s.key('e', () => s.nav(1), { style: 'border-color:blue' });
			s.key('q', () => s.nav(-1), { style: 'border-color:red' });
			s.key('1', () => s.full());
			s.key('2', () => s.lay(1));
			s.key('3', () => s.lay(2));
			s.key('Tab', (e) => (e.preventDefault(), s.cycle()));
			s.key('z', () => s.toggleKeyboard());

			document.addEventListener('keydown', (e) => {
				s.key(e.key, null, {}, e);
				const keyEl = s.keyboard.querySelector(`[data-key="${e.key}"]`);
				if (keyEl) keyEl.classList.add('pressed');
			});

			document.addEventListener('keyup', (e) => {
				const keyEl = s.keyboard.querySelector(`[data-key="${e.key}"]`);
				if (keyEl) keyEl.classList.remove('pressed');
			});

			window.pathless = {
				context: () => ({
					panel: s.p.el,
					frame: s.p.el.firstElementChild,
					state: s.st,
				}),
				update: (k, v) => s.set(k, v),
				fetch: (url, opts) => s.get(url, opts?.key),
				W: (h, opt = {}) => s.key('w', h, opt),
				A: (h, opt = {}) => s.key('a', h, opt),
				S: (h, opt = {}) => s.key('s', h, opt),
				D: (h, opt = {}) => s.key('d', h, opt),
				onKey: (k, h, opt = {}) => s.key(k, h, opt),
			};
			s.render();
		</script>
	</body>
</html>
